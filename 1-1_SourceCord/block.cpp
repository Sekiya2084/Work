/*==============================================================================

   敵管理 [block.cpp]
														 Author :関谷　勇人
														 Date   :2023/06/29
--------------------------------------------------------------------------------

==============================================================================*/
#include "block.h"
#include "input.h"
#include "sprite.h"
#include "texture.h"
#include "map.h"


//*****************************************************************************
// マクロ定義
//*****************************************************************************

//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************

//*****************************************************************************
// グローバル変数
//*****************************************************************************
static BLOCK g_Block[MAX_BLOCK]; //実体
//テクスチャID

//=============================================================================
// 初期化処理
//=============================================================================
void InitBlock(void)
{
	ID3D11Device* pDevice = GetDevice();

	//テクスチャの読み込み

	//初期化
	for (int i = 0; i < MAX_BLOCK; i++)
	{
		g_Block[i].pos = D3DXVECTOR2(0.0f, 0.0f);
		g_Block[i].size = D3DXVECTOR2(0.0f, 0.0f);
		g_Block[i].type = 0;
		g_Block[i].use = false;
	}
}

//=============================================================================
// 終了処理
//=============================================================================
void UninitBlock(void)
{

}

//=============================================================================
// 更新処理
//=============================================================================
void UpdateBlock(void)
{
	for (int i = 0; i < MAX_BLOCK; i++)
	{
		if (g_Block[i].use)
		{
			////画面外判定(画面外へ行った時使用フラグをFalseへ)
			//if (g_Block[i].pos.x > SCREEN_WIDTH + g_Block[i].size.x / 2 ||
			//	g_Block[i].pos.y > SCREEN_HEIGHT + g_Block[i].size.y / 2 ||
			//	g_Block[i].pos.x < 0.0f - g_Block[i].size.x / 2 ||
			//	g_Block[i].pos.y < 0.0f - g_Block[i].size.y / 2
			//	)
			//{
			//	g_Block[i].use = false;
			//}
		}
	}
}

//=============================================================================
// 描画処理
//=============================================================================
void DrawBlock(void)
{

}

//=============================================================================
// セット関数
//=============================================================================
void SetBlock(D3DXVECTOR2 spos, D3DXVECTOR2 ssize,int stype)
{
	for (int i = 0; i < MAX_BLOCK; i++)
	{
		if (!g_Block[i].use)
		{
			g_Block[i].pos = spos;
			g_Block[i].size = ssize;
			g_Block[i].type = stype;
			g_Block[i].use = true;
			break;
		}
	}
}

//=============================================================================
// 実体のアドレス取得関数
//=============================================================================
BLOCK* GetBlock(void)
{
	return g_Block;
}